
/**
 * Stock service for database operations
 */
import { v4 as uuidv4 } from 'uuid';
import { StockHolding } from '@/types';
import { executeQuery } from './dbConnector';
import { createAuditRecord } from '../auditService';

// Helper function to map API stock object to frontend StockHolding type
const mapApiStockToFrontend = (apiStock: any): StockHolding => {
  if (!apiStock) return null as any; // Or handle as per error strategy

  return {
    id: apiStock.id,
    symbol: apiStock.symbol,
    name: apiStock.companyName || apiStock.name, // API uses companyName, frontend uses name
    quantity: Number(apiStock.quantity) || 0,
    averageBuyPrice: Number(apiStock.purchasePrice || apiStock.averageBuyPrice) || 0, // API uses purchasePrice
    currentPrice: Number(apiStock.currentPrice) || 0,
    // 'value' from API is the DB generated value: quantity * COALESCE(current_price, purchase_price)
    value: Number(apiStock.value) || 0,
    // 'change' and 'changePercent' might not be directly from this API/DB.
    // Default to 0 if not present.
    change: Number(apiStock.change) || 0,
    changePercent: Number(apiStock.changePercent) || 0,
    sector: apiStock.sector,
    lastUpdated: apiStock.lastUpdated ? new Date(apiStock.lastUpdated) : new Date(),
    familyMemberId: apiStock.familyMemberId,
  };
};

// Get all stocks
export const getStocks = async (): Promise<StockHolding[]> => {
  try {
    const apiStocks = await executeQuery<any[]>('/stocks');
    return apiStocks.map(mapApiStockToFrontend).filter(stock => stock !== null);
  } catch (error) {
    console.error('Failed to fetch stocks from database:', error);
    throw error;
  }
};

// Add a new stock
export const addStock = async (stock: Partial<StockHolding>): Promise<StockHolding> => {
  try {
    // Validate required fields (using frontend names like averageBuyPrice)
    if (!stock.symbol || !stock.name || stock.quantity === undefined || stock.averageBuyPrice === undefined) {
      throw new Error('Missing required fields: symbol, name, quantity, averageBuyPrice');
    }
    
    // Data to send to API (API expects purchasePrice, companyName)
    const apiPayload = {
      id: stock.id || uuidv4(),
      symbol: stock.symbol,
      name: stock.name, // API createStock expects 'name'
      quantity: stock.quantity,
      averageBuyPrice: stock.averageBuyPrice, // API createStock expects 'averageBuyPrice'
      currentPrice: stock.currentPrice || stock.averageBuyPrice,
      sector: stock.sector || 'Unspecified',
      familyMemberId: stock.familyMemberId || '',
      notes: (stock as any).notes || '', // Assuming notes might be part of StockHolding extension
      // 'value' will be generated by DB
    };
    
    const savedApiStock = await executeQuery<any>('/stocks', 'POST', apiPayload);
    const result = mapApiStockToFrontend(savedApiStock);
    
    createAuditRecord(result.id, 'stock', 'create', result);
    return result;
  } catch (error) {
    console.error('Failed to add stock to database:', error);
    throw error;
  }
};

// Update an existing stock
export const updateStock = async (id: string, updates: Partial<StockHolding>): Promise<StockHolding> => {
  try {
    // Map frontend field names to API expected field names if necessary
    const apiUpdates: Record<string, any> = {};
    for (const key in updates) {
      if (Object.prototype.hasOwnProperty.call(updates, key)) {
        const value = (updates as any)[key];
        if (key === 'name') apiUpdates['companyName'] = value;
        else if (key === 'averageBuyPrice') apiUpdates['purchasePrice'] = value;
        else apiUpdates[key] = value;
      }
    }
    apiUpdates.lastUpdated = new Date(); // Ensure lastUpdated is set for the API
    
    const updatedApiStock = await executeQuery<any>(`/stocks/${id}`, 'PUT', apiUpdates);
    const result = mapApiStockToFrontend(updatedApiStock);
    
    createAuditRecord(id, 'stock', 'update', {
      current: result,
      changes: updates // Log original frontend changes
    });
    
    return result;
  } catch (error) {
    console.error(`Failed to update stock ${id} in database:`, error);
    throw error;
  }
};

// Delete a stock
export const deleteStock = async (id: string): Promise<boolean> => {
  try {
    await executeQuery(`/stocks/${id}`, 'DELETE');
    createAuditRecord(id, 'stock', 'delete', { id });
    return true;
  } catch (error) {
    console.error(`Failed to delete stock ${id} from database:`, error);
    throw error;
  }
};

// Get a single stock by ID
export const getStockById = async (id: string): Promise<StockHolding | null> => {
  try {
    const apiStock = await executeQuery<any>(`/stocks/${id}`);
    if (!apiStock) return null;
    return mapApiStockToFrontend(apiStock);
  } catch (error) {
    console.error(`Failed to fetch stock ${id} from database:`, error);
    return null; // Or throw error, depending on desired behavior
  }
};
